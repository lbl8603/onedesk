// This file is generated by rust-protobuf 3.0.0-alpha.1. Do not edit
// .proto file is parsed by protobuf-codegen-pure=3.0.0-alpha.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `rendezvous.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_ALPHA_1;

#[derive(PartialEq,Clone,Default)]
pub struct RegisterPeer {
    // message fields
    pub user_id: ::std::string::String,
    pub server_key: ::std::string::String,
    pub cert: ::std::vec::Vec<u8>,
    pub pub_key: ::std::vec::Vec<u8>,
    pub u_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisterPeer {
    fn default() -> &'a RegisterPeer {
        <RegisterPeer as ::protobuf::Message>::default_instance()
    }
}

impl RegisterPeer {
    pub fn new() -> RegisterPeer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &RegisterPeer| { &m.user_id },
            |m: &mut RegisterPeer| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "server_key",
            |m: &RegisterPeer| { &m.server_key },
            |m: &mut RegisterPeer| { &mut m.server_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cert",
            |m: &RegisterPeer| { &m.cert },
            |m: &mut RegisterPeer| { &mut m.cert },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pub_key",
            |m: &RegisterPeer| { &m.pub_key },
            |m: &mut RegisterPeer| { &mut m.pub_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "u_id",
            |m: &RegisterPeer| { &m.u_id },
            |m: &mut RegisterPeer| { &mut m.u_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegisterPeer>(
            "RegisterPeer",
            0,
            fields,
        )
    }
}

impl ::protobuf::Message for RegisterPeer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.user_id = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.server_key = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cert = is.read_bytes()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.pub_key = is.read_bytes()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.u_id = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_id);
        }
        if !self.server_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.server_key);
        }
        if !self.cert.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.cert);
        }
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.pub_key);
        }
        if !self.u_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.u_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.user_id.is_empty() {
            os.write_string(1, &self.user_id)?;
        }
        if !self.server_key.is_empty() {
            os.write_string(2, &self.server_key)?;
        }
        if !self.cert.is_empty() {
            os.write_bytes(3, &self.cert)?;
        }
        if !self.pub_key.is_empty() {
            os.write_bytes(4, &self.pub_key)?;
        }
        if !self.u_id.is_empty() {
            os.write_string(5, &self.u_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RegisterPeer {
        RegisterPeer::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 0)
    }

    fn default_instance() -> &'static RegisterPeer {
        static instance: RegisterPeer = RegisterPeer {
            user_id: ::std::string::String::new(),
            server_key: ::std::string::String::new(),
            cert: ::std::vec::Vec::new(),
            pub_key: ::std::vec::Vec::new(),
            u_id: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for RegisterPeer {
    fn clear(&mut self) {
        self.user_id.clear();
        self.server_key.clear();
        self.cert.clear();
        self.pub_key.clear();
        self.u_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisterPeer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterPeer {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct RegisterPeerResponse {
    // message fields
    pub code: ::protobuf::ProtobufEnumOrUnknown<register_peer_response::Code>,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisterPeerResponse {
    fn default() -> &'a RegisterPeerResponse {
        <RegisterPeerResponse as ::protobuf::Message>::default_instance()
    }
}

impl RegisterPeerResponse {
    pub fn new() -> RegisterPeerResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &RegisterPeerResponse| { &m.code },
            |m: &mut RegisterPeerResponse| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &RegisterPeerResponse| { &m.message },
            |m: &mut RegisterPeerResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegisterPeerResponse>(
            "RegisterPeerResponse",
            1,
            fields,
        )
    }
}

impl ::protobuf::Message for RegisterPeerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.code = is.read_enum_or_unknown()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != ::protobuf::ProtobufEnumOrUnknown::new(register_peer_response::Code::Success) {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != ::protobuf::ProtobufEnumOrUnknown::new(register_peer_response::Code::Success) {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&self.code))?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RegisterPeerResponse {
        RegisterPeerResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 1)
    }

    fn default_instance() -> &'static RegisterPeerResponse {
        static instance: RegisterPeerResponse = RegisterPeerResponse {
            code: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            message: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for RegisterPeerResponse {
    fn clear(&mut self) {
        self.code = ::protobuf::ProtobufEnumOrUnknown::new(register_peer_response::Code::Success);
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisterPeerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterPeerResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RegisterPeerResponse`
pub mod register_peer_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    pub enum Code {
        Success = 0,
        Fail = 1,
        Error = 2,
        Repeat = 3,
        KeyNotMatch = 4,
    }

    impl ::protobuf::ProtobufEnum for Code {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Code> {
            match value {
                0 => ::std::option::Option::Some(Code::Success),
                1 => ::std::option::Option::Some(Code::Fail),
                2 => ::std::option::Option::Some(Code::Error),
                3 => ::std::option::Option::Some(Code::Repeat),
                4 => ::std::option::Option::Some(Code::KeyNotMatch),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [Code] = &[
                Code::Success,
                Code::Fail,
                Code::Error,
                Code::Repeat,
                Code::KeyNotMatch,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 0)
        }
    }

    impl ::std::default::Default for Code {
        fn default() -> Self {
            Code::Success
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Code {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl Code {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<Code>("RegisterPeerResponse.Code", 0)
        }
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestRelay {
    // message fields
    pub peer_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestRelay {
    fn default() -> &'a RequestRelay {
        <RequestRelay as ::protobuf::Message>::default_instance()
    }
}

impl RequestRelay {
    pub fn new() -> RequestRelay {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "peer_id",
            |m: &RequestRelay| { &m.peer_id },
            |m: &mut RequestRelay| { &mut m.peer_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestRelay>(
            "RequestRelay",
            2,
            fields,
        )
    }
}

impl ::protobuf::Message for RequestRelay {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.peer_id = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.peer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.peer_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.peer_id.is_empty() {
            os.write_string(1, &self.peer_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RequestRelay {
        RequestRelay::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 2)
    }

    fn default_instance() -> &'static RequestRelay {
        static instance: RequestRelay = RequestRelay {
            peer_id: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for RequestRelay {
    fn clear(&mut self) {
        self.peer_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestRelay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestRelay {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct RelayResponse {
    // message fields
    pub ralay_id: ::std::string::String,
    pub relay_addr: ::std::string::String,
    pub is_control: bool,
    pub peer_pub_key: ::std::vec::Vec<u8>,
    pub peer_id: ::std::string::String,
    pub ralay_pub_key: ::std::vec::Vec<u8>,
    pub code: ::protobuf::ProtobufEnumOrUnknown<relay_response::Code>,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelayResponse {
    fn default() -> &'a RelayResponse {
        <RelayResponse as ::protobuf::Message>::default_instance()
    }
}

impl RelayResponse {
    pub fn new() -> RelayResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ralay_id",
            |m: &RelayResponse| { &m.ralay_id },
            |m: &mut RelayResponse| { &mut m.ralay_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "relay_addr",
            |m: &RelayResponse| { &m.relay_addr },
            |m: &mut RelayResponse| { &mut m.relay_addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_control",
            |m: &RelayResponse| { &m.is_control },
            |m: &mut RelayResponse| { &mut m.is_control },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "peer_pub_key",
            |m: &RelayResponse| { &m.peer_pub_key },
            |m: &mut RelayResponse| { &mut m.peer_pub_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "peer_id",
            |m: &RelayResponse| { &m.peer_id },
            |m: &mut RelayResponse| { &mut m.peer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ralay_pub_key",
            |m: &RelayResponse| { &m.ralay_pub_key },
            |m: &mut RelayResponse| { &mut m.ralay_pub_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &RelayResponse| { &m.code },
            |m: &mut RelayResponse| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &RelayResponse| { &m.message },
            |m: &mut RelayResponse| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RelayResponse>(
            "RelayResponse",
            3,
            fields,
        )
    }
}

impl ::protobuf::Message for RelayResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ralay_id = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.relay_addr = is.read_string()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.is_control = is.read_bool()?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.peer_pub_key = is.read_bytes()?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.peer_id = is.read_string()?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ralay_pub_key = is.read_bytes()?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.code = is.read_enum_or_unknown()?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = is.read_string()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ralay_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ralay_id);
        }
        if !self.relay_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.relay_addr);
        }
        if self.is_control != false {
            my_size += 2;
        }
        if !self.peer_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.peer_pub_key);
        }
        if !self.peer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.peer_id);
        }
        if !self.ralay_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.ralay_pub_key);
        }
        if self.code != ::protobuf::ProtobufEnumOrUnknown::new(relay_response::Code::Success) {
            my_size += ::protobuf::rt::enum_or_unknown_size(7, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ralay_id.is_empty() {
            os.write_string(1, &self.ralay_id)?;
        }
        if !self.relay_addr.is_empty() {
            os.write_string(2, &self.relay_addr)?;
        }
        if self.is_control != false {
            os.write_bool(3, self.is_control)?;
        }
        if !self.peer_pub_key.is_empty() {
            os.write_bytes(4, &self.peer_pub_key)?;
        }
        if !self.peer_id.is_empty() {
            os.write_string(5, &self.peer_id)?;
        }
        if !self.ralay_pub_key.is_empty() {
            os.write_bytes(6, &self.ralay_pub_key)?;
        }
        if self.code != ::protobuf::ProtobufEnumOrUnknown::new(relay_response::Code::Success) {
            os.write_enum(7, ::protobuf::ProtobufEnumOrUnknown::value(&self.code))?;
        }
        if !self.message.is_empty() {
            os.write_string(8, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RelayResponse {
        RelayResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 3)
    }

    fn default_instance() -> &'static RelayResponse {
        static instance: RelayResponse = RelayResponse {
            ralay_id: ::std::string::String::new(),
            relay_addr: ::std::string::String::new(),
            is_control: false,
            peer_pub_key: ::std::vec::Vec::new(),
            peer_id: ::std::string::String::new(),
            ralay_pub_key: ::std::vec::Vec::new(),
            code: ::protobuf::ProtobufEnumOrUnknown::from_i32(0),
            message: ::std::string::String::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for RelayResponse {
    fn clear(&mut self) {
        self.ralay_id.clear();
        self.relay_addr.clear();
        self.is_control = false;
        self.peer_pub_key.clear();
        self.peer_id.clear();
        self.ralay_pub_key.clear();
        self.code = ::protobuf::ProtobufEnumOrUnknown::new(relay_response::Code::Success);
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelayResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelayResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RelayResponse`
pub mod relay_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    pub enum Code {
        Success = 0,
        Fail = 1,
        Offline = 2,
    }

    impl ::protobuf::ProtobufEnum for Code {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Code> {
            match value {
                0 => ::std::option::Option::Some(Code::Success),
                1 => ::std::option::Option::Some(Code::Fail),
                2 => ::std::option::Option::Some(Code::Offline),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [Code] = &[
                Code::Success,
                Code::Fail,
                Code::Offline,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 1)
        }
    }

    impl ::std::default::Default for Code {
        fn default() -> Self {
            Code::Success
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Code {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl Code {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<Code>("RelayResponse.Code", 1)
        }
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ping {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ping {
    fn default() -> &'a Ping {
        <Ping as ::protobuf::Message>::default_instance()
    }
}

impl Ping {
    pub fn new() -> Ping {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Ping>(
            "Ping",
            4,
            fields,
        )
    }
}

impl ::protobuf::Message for Ping {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Ping {
        Ping::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 4)
    }

    fn default_instance() -> &'static Ping {
        static instance: Ping = Ping {
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Ping {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ping {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct RendezvousMessage {
    // message oneof groups
    pub union: ::std::option::Option<rendezvous_message::Union>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RendezvousMessage {
    fn default() -> &'a RendezvousMessage {
        <RendezvousMessage as ::protobuf::Message>::default_instance()
    }
}

impl RendezvousMessage {
    pub fn new() -> RendezvousMessage {
        ::std::default::Default::default()
    }

    // .RegisterPeer register_peer = 1;

    pub fn get_register_peer(&self) -> &RegisterPeer {
        match self.union {
            ::std::option::Option::Some(rendezvous_message::Union::register_peer(ref v)) => v,
            _ => <RegisterPeer as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_register_peer(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_register_peer(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(rendezvous_message::Union::register_peer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_register_peer(&mut self, v: RegisterPeer) {
        self.union = ::std::option::Option::Some(rendezvous_message::Union::register_peer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_register_peer(&mut self) -> &mut RegisterPeer {
        if let ::std::option::Option::Some(rendezvous_message::Union::register_peer(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(rendezvous_message::Union::register_peer(RegisterPeer::new()));
        }
        match self.union {
            ::std::option::Option::Some(rendezvous_message::Union::register_peer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_register_peer(&mut self) -> RegisterPeer {
        if self.has_register_peer() {
            match self.union.take() {
                ::std::option::Option::Some(rendezvous_message::Union::register_peer(v)) => v,
                _ => panic!(),
            }
        } else {
            RegisterPeer::new()
        }
    }

    // .RegisterPeerResponse register_peer_response = 2;

    pub fn get_register_peer_response(&self) -> &RegisterPeerResponse {
        match self.union {
            ::std::option::Option::Some(rendezvous_message::Union::register_peer_response(ref v)) => v,
            _ => <RegisterPeerResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_register_peer_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_register_peer_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(rendezvous_message::Union::register_peer_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_register_peer_response(&mut self, v: RegisterPeerResponse) {
        self.union = ::std::option::Option::Some(rendezvous_message::Union::register_peer_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_register_peer_response(&mut self) -> &mut RegisterPeerResponse {
        if let ::std::option::Option::Some(rendezvous_message::Union::register_peer_response(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(rendezvous_message::Union::register_peer_response(RegisterPeerResponse::new()));
        }
        match self.union {
            ::std::option::Option::Some(rendezvous_message::Union::register_peer_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_register_peer_response(&mut self) -> RegisterPeerResponse {
        if self.has_register_peer_response() {
            match self.union.take() {
                ::std::option::Option::Some(rendezvous_message::Union::register_peer_response(v)) => v,
                _ => panic!(),
            }
        } else {
            RegisterPeerResponse::new()
        }
    }

    // .RequestRelay request_relay = 3;

    pub fn get_request_relay(&self) -> &RequestRelay {
        match self.union {
            ::std::option::Option::Some(rendezvous_message::Union::request_relay(ref v)) => v,
            _ => <RequestRelay as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_request_relay(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_request_relay(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(rendezvous_message::Union::request_relay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_relay(&mut self, v: RequestRelay) {
        self.union = ::std::option::Option::Some(rendezvous_message::Union::request_relay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_relay(&mut self) -> &mut RequestRelay {
        if let ::std::option::Option::Some(rendezvous_message::Union::request_relay(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(rendezvous_message::Union::request_relay(RequestRelay::new()));
        }
        match self.union {
            ::std::option::Option::Some(rendezvous_message::Union::request_relay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_relay(&mut self) -> RequestRelay {
        if self.has_request_relay() {
            match self.union.take() {
                ::std::option::Option::Some(rendezvous_message::Union::request_relay(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestRelay::new()
        }
    }

    // .RelayResponse relay_response = 4;

    pub fn get_relay_response(&self) -> &RelayResponse {
        match self.union {
            ::std::option::Option::Some(rendezvous_message::Union::relay_response(ref v)) => v,
            _ => <RelayResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_relay_response(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_relay_response(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(rendezvous_message::Union::relay_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relay_response(&mut self, v: RelayResponse) {
        self.union = ::std::option::Option::Some(rendezvous_message::Union::relay_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relay_response(&mut self) -> &mut RelayResponse {
        if let ::std::option::Option::Some(rendezvous_message::Union::relay_response(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(rendezvous_message::Union::relay_response(RelayResponse::new()));
        }
        match self.union {
            ::std::option::Option::Some(rendezvous_message::Union::relay_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relay_response(&mut self) -> RelayResponse {
        if self.has_relay_response() {
            match self.union.take() {
                ::std::option::Option::Some(rendezvous_message::Union::relay_response(v)) => v,
                _ => panic!(),
            }
        } else {
            RelayResponse::new()
        }
    }

    // .Ping ping = 5;

    pub fn get_ping(&self) -> &Ping {
        match self.union {
            ::std::option::Option::Some(rendezvous_message::Union::ping(ref v)) => v,
            _ => <Ping as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ping(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(rendezvous_message::Union::ping(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: Ping) {
        self.union = ::std::option::Option::Some(rendezvous_message::Union::ping(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ping(&mut self) -> &mut Ping {
        if let ::std::option::Option::Some(rendezvous_message::Union::ping(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(rendezvous_message::Union::ping(Ping::new()));
        }
        match self.union {
            ::std::option::Option::Some(rendezvous_message::Union::ping(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ping(&mut self) -> Ping {
        if self.has_ping() {
            match self.union.take() {
                ::std::option::Option::Some(rendezvous_message::Union::ping(v)) => v,
                _ => panic!(),
            }
        } else {
            Ping::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RegisterPeer>(
            "register_peer",
            RendezvousMessage::has_register_peer,
            RendezvousMessage::get_register_peer,
            RendezvousMessage::mut_register_peer,
            RendezvousMessage::set_register_peer,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RegisterPeerResponse>(
            "register_peer_response",
            RendezvousMessage::has_register_peer_response,
            RendezvousMessage::get_register_peer_response,
            RendezvousMessage::mut_register_peer_response,
            RendezvousMessage::set_register_peer_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestRelay>(
            "request_relay",
            RendezvousMessage::has_request_relay,
            RendezvousMessage::get_request_relay,
            RendezvousMessage::mut_request_relay,
            RendezvousMessage::set_request_relay,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RelayResponse>(
            "relay_response",
            RendezvousMessage::has_relay_response,
            RendezvousMessage::get_relay_response,
            RendezvousMessage::mut_relay_response,
            RendezvousMessage::set_relay_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Ping>(
            "ping",
            RendezvousMessage::has_ping,
            RendezvousMessage::get_ping,
            RendezvousMessage::mut_ping,
            RendezvousMessage::set_ping,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RendezvousMessage>(
            "RendezvousMessage",
            5,
            fields,
        )
    }
}

impl ::protobuf::Message for RendezvousMessage {
    fn is_initialized(&self) -> bool {
        if let Some(rendezvous_message::Union::register_peer(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(rendezvous_message::Union::register_peer_response(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(rendezvous_message::Union::request_relay(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(rendezvous_message::Union::relay_response(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(rendezvous_message::Union::ping(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(rendezvous_message::Union::register_peer(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(rendezvous_message::Union::register_peer_response(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(rendezvous_message::Union::request_relay(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(rendezvous_message::Union::relay_response(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(rendezvous_message::Union::ping(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &rendezvous_message::Union::register_peer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &rendezvous_message::Union::register_peer_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &rendezvous_message::Union::request_relay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &rendezvous_message::Union::relay_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &rendezvous_message::Union::ping(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &rendezvous_message::Union::register_peer(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &rendezvous_message::Union::register_peer_response(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &rendezvous_message::Union::request_relay(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &rendezvous_message::Union::relay_response(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &rendezvous_message::Union::ping(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RendezvousMessage {
        RendezvousMessage::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 5)
    }

    fn default_instance() -> &'static RendezvousMessage {
        static instance: RendezvousMessage = RendezvousMessage {
            union: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for RendezvousMessage {
    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RendezvousMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RendezvousMessage {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RendezvousMessage`
pub mod rendezvous_message {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Union {
        register_peer(super::RegisterPeer),
        register_peer_response(super::RegisterPeerResponse),
        request_relay(super::RequestRelay),
        relay_response(super::RelayResponse),
        ping(super::Ping),
    }

    impl ::protobuf::Oneof for Union {
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelayConn {
    // message fields
    pub relay_id: ::std::string::String,
    pub key: ::std::vec::Vec<u8>,
    pub nonce: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelayConn {
    fn default() -> &'a RelayConn {
        <RelayConn as ::protobuf::Message>::default_instance()
    }
}

impl RelayConn {
    pub fn new() -> RelayConn {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "relay_id",
            |m: &RelayConn| { &m.relay_id },
            |m: &mut RelayConn| { &mut m.relay_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &RelayConn| { &m.key },
            |m: &mut RelayConn| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nonce",
            |m: &RelayConn| { &m.nonce },
            |m: &mut RelayConn| { &mut m.nonce },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RelayConn>(
            "RelayConn",
            6,
            fields,
        )
    }
}

impl ::protobuf::Message for RelayConn {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.relay_id = is.read_string()?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.key = is.read_bytes()?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.nonce = is.read_bytes()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.relay_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.relay_id);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.key);
        }
        if !self.nonce.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.nonce);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.relay_id.is_empty() {
            os.write_string(1, &self.relay_id)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(2, &self.key)?;
        }
        if !self.nonce.is_empty() {
            os.write_bytes(3, &self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RelayConn {
        RelayConn::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 6)
    }

    fn default_instance() -> &'static RelayConn {
        static instance: RelayConn = RelayConn {
            relay_id: ::std::string::String::new(),
            key: ::std::vec::Vec::new(),
            nonce: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for RelayConn {
    fn clear(&mut self) {
        self.relay_id.clear();
        self.key.clear();
        self.nonce.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelayConn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelayConn {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct RelayStart {
    // message fields
    pub rand: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelayStart {
    fn default() -> &'a RelayStart {
        <RelayStart as ::protobuf::Message>::default_instance()
    }
}

impl RelayStart {
    pub fn new() -> RelayStart {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rand",
            |m: &RelayStart| { &m.rand },
            |m: &mut RelayStart| { &mut m.rand },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RelayStart>(
            "RelayStart",
            7,
            fields,
        )
    }
}

impl ::protobuf::Message for RelayStart {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rand = is.read_uint64()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.rand != 0 {
            my_size += ::protobuf::rt::value_size(1, self.rand, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.rand != 0 {
            os.write_uint64(1, self.rand)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RelayStart {
        RelayStart::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 7)
    }

    fn default_instance() -> &'static RelayStart {
        static instance: RelayStart = RelayStart {
            rand: 0,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for RelayStart {
    fn clear(&mut self) {
        self.rand = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelayStart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelayStart {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct RelayMessage {
    // message oneof groups
    pub union: ::std::option::Option<relay_message::Union>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelayMessage {
    fn default() -> &'a RelayMessage {
        <RelayMessage as ::protobuf::Message>::default_instance()
    }
}

impl RelayMessage {
    pub fn new() -> RelayMessage {
        ::std::default::Default::default()
    }

    // .RelayConn relay_conn = 1;

    pub fn get_relay_conn(&self) -> &RelayConn {
        match self.union {
            ::std::option::Option::Some(relay_message::Union::relay_conn(ref v)) => v,
            _ => <RelayConn as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_relay_conn(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_relay_conn(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(relay_message::Union::relay_conn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relay_conn(&mut self, v: RelayConn) {
        self.union = ::std::option::Option::Some(relay_message::Union::relay_conn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relay_conn(&mut self) -> &mut RelayConn {
        if let ::std::option::Option::Some(relay_message::Union::relay_conn(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(relay_message::Union::relay_conn(RelayConn::new()));
        }
        match self.union {
            ::std::option::Option::Some(relay_message::Union::relay_conn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relay_conn(&mut self) -> RelayConn {
        if self.has_relay_conn() {
            match self.union.take() {
                ::std::option::Option::Some(relay_message::Union::relay_conn(v)) => v,
                _ => panic!(),
            }
        } else {
            RelayConn::new()
        }
    }

    // .RelayStart relay_start = 2;

    pub fn get_relay_start(&self) -> &RelayStart {
        match self.union {
            ::std::option::Option::Some(relay_message::Union::relay_start(ref v)) => v,
            _ => <RelayStart as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_relay_start(&mut self) {
        self.union = ::std::option::Option::None;
    }

    pub fn has_relay_start(&self) -> bool {
        match self.union {
            ::std::option::Option::Some(relay_message::Union::relay_start(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_relay_start(&mut self, v: RelayStart) {
        self.union = ::std::option::Option::Some(relay_message::Union::relay_start(v))
    }

    // Mutable pointer to the field.
    pub fn mut_relay_start(&mut self) -> &mut RelayStart {
        if let ::std::option::Option::Some(relay_message::Union::relay_start(_)) = self.union {
        } else {
            self.union = ::std::option::Option::Some(relay_message::Union::relay_start(RelayStart::new()));
        }
        match self.union {
            ::std::option::Option::Some(relay_message::Union::relay_start(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_relay_start(&mut self) -> RelayStart {
        if self.has_relay_start() {
            match self.union.take() {
                ::std::option::Option::Some(relay_message::Union::relay_start(v)) => v,
                _ => panic!(),
            }
        } else {
            RelayStart::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RelayConn>(
            "relay_conn",
            RelayMessage::has_relay_conn,
            RelayMessage::get_relay_conn,
            RelayMessage::mut_relay_conn,
            RelayMessage::set_relay_conn,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RelayStart>(
            "relay_start",
            RelayMessage::has_relay_start,
            RelayMessage::get_relay_start,
            RelayMessage::mut_relay_start,
            RelayMessage::set_relay_start,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RelayMessage>(
            "RelayMessage",
            8,
            fields,
        )
    }
}

impl ::protobuf::Message for RelayMessage {
    fn is_initialized(&self) -> bool {
        if let Some(relay_message::Union::relay_conn(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(relay_message::Union::relay_start(ref v)) = self.union {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(relay_message::Union::relay_conn(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.union = ::std::option::Option::Some(relay_message::Union::relay_start(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &relay_message::Union::relay_conn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &relay_message::Union::relay_start(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.union {
            match v {
                &relay_message::Union::relay_conn(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &relay_message::Union::relay_start(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RelayMessage {
        RelayMessage::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 8)
    }

    fn default_instance() -> &'static RelayMessage {
        static instance: RelayMessage = RelayMessage {
            union: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for RelayMessage {
    fn clear(&mut self) {
        self.union = ::std::option::Option::None;
        self.union = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelayMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelayMessage {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RelayMessage`
pub mod relay_message {

    #[derive(Clone,PartialEq,Debug)]
    pub enum Union {
        relay_conn(super::RelayConn),
        relay_start(super::RelayStart),
    }

    impl ::protobuf::Oneof for Union {
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10rendezvous.proto\"\x92\x01\n\x0cRegisterPeer\x12\x19\n\x07user_id\
    \x18\x01\x20\x01(\tR\x06userIdB\0\x12\x1f\n\nserver_key\x18\x02\x20\x01(\
    \tR\tserverKeyB\0\x12\x14\n\x04cert\x18\x03\x20\x01(\x0cR\x04certB\0\x12\
    \x19\n\x07pub_key\x18\x04\x20\x01(\x0cR\x06pubKeyB\0\x12\x13\n\x04u_id\
    \x18\x05\x20\x01(\tR\x03uIdB\0:\0\"\xb9\x01\n\x14RegisterPeerResponse\
    \x120\n\x04code\x18\x01\x20\x01(\x0e2\x1a.RegisterPeerResponse.CodeR\x04\
    codeB\0\x12\x1a\n\x07message\x18\x02\x20\x01(\tR\x07messageB\0\"Q\n\x04C\
    ode\x12\r\n\x07Success\x10\0\x1a\0\x12\n\n\x04Fail\x10\x01\x1a\0\x12\x0b\
    \n\x05Error\x10\x02\x1a\0\x12\x0c\n\x06Repeat\x10\x03\x1a\0\x12\x11\n\
    \x0bKeyNotMatch\x10\x04\x1a\0\x1a\0:\0\"+\n\x0cRequestRelay\x12\x19\n\
    \x07peer_id\x18\x01\x20\x01(\tR\x06peerIdB\0:\0\"\xd0\x02\n\rRelayRespon\
    se\x12\x1b\n\x08ralay_id\x18\x01\x20\x01(\tR\x07ralayIdB\0\x12\x1f\n\nre\
    lay_addr\x18\x02\x20\x01(\tR\trelayAddrB\0\x12\x1f\n\nis_control\x18\x03\
    \x20\x01(\x08R\tisControlB\0\x12\"\n\x0cpeer_pub_key\x18\x04\x20\x01(\
    \x0cR\npeerPubKeyB\0\x12\x19\n\x07peer_id\x18\x05\x20\x01(\tR\x06peerIdB\
    \0\x12$\n\rralay_pub_key\x18\x06\x20\x01(\x0cR\x0bralayPubKeyB\0\x12)\n\
    \x04code\x18\x07\x20\x01(\x0e2\x13.RelayResponse.CodeR\x04codeB\0\x12\
    \x1a\n\x07message\x18\x08\x20\x01(\tR\x07messageB\0\"2\n\x04Code\x12\r\n\
    \x07Success\x10\0\x1a\0\x12\n\n\x04Fail\x10\x01\x1a\0\x12\r\n\x07Offline\
    \x10\x02\x1a\0\x1a\0:\0\"\x08\n\x04Ping:\0\"\xbb\x02\n\x11RendezvousMess\
    age\x126\n\rregister_peer\x18\x01\x20\x01(\x0b2\r.RegisterPeerH\0R\x0cre\
    gisterPeerB\0\x12O\n\x16register_peer_response\x18\x02\x20\x01(\x0b2\x15\
    .RegisterPeerResponseH\0R\x14registerPeerResponseB\0\x126\n\rrequest_rel\
    ay\x18\x03\x20\x01(\x0b2\r.RequestRelayH\0R\x0crequestRelayB\0\x129\n\
    \x0erelay_response\x18\x04\x20\x01(\x0b2\x0e.RelayResponseH\0R\rrelayRes\
    ponseB\0\x12\x1d\n\x04ping\x18\x05\x20\x01(\x0b2\x05.PingH\0R\x04pingB\0\
    B\t\n\x05union\x12\0:\0\"V\n\tRelayConn\x12\x1b\n\x08relay_id\x18\x01\
    \x20\x01(\tR\x07relayIdB\0\x12\x12\n\x03key\x18\x02\x20\x01(\x0cR\x03key\
    B\0\x12\x16\n\x05nonce\x18\x03\x20\x01(\x0cR\x05nonceB\0:\0\"$\n\nRelayS\
    tart\x12\x14\n\x04rand\x18\x01\x20\x01(\x04R\x04randB\0:\0\"|\n\x0cRelay\
    Message\x12-\n\nrelay_conn\x18\x01\x20\x01(\x0b2\n.RelayConnH\0R\trelayC\
    onnB\0\x120\n\x0brelay_start\x18\x02\x20\x01(\x0b2\x0b.RelayStartH\0R\nr\
    elayStartB\0B\t\n\x05union\x12\0:\0B\0b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> ::protobuf::reflect::FileDescriptor {
    static file_descriptor_lazy: ::protobuf::rt::LazyV2<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::LazyV2::INIT;
    let file_descriptor = file_descriptor_lazy.get(|| {
        let mut deps = ::std::vec::Vec::new();
        let mut messages = ::std::vec::Vec::new();
        messages.push(RegisterPeer::generated_message_descriptor_data());
        messages.push(RegisterPeerResponse::generated_message_descriptor_data());
        messages.push(RequestRelay::generated_message_descriptor_data());
        messages.push(RelayResponse::generated_message_descriptor_data());
        messages.push(Ping::generated_message_descriptor_data());
        messages.push(RendezvousMessage::generated_message_descriptor_data());
        messages.push(RelayConn::generated_message_descriptor_data());
        messages.push(RelayStart::generated_message_descriptor_data());
        messages.push(RelayMessage::generated_message_descriptor_data());
        let mut enums = ::std::vec::Vec::new();
        enums.push(register_peer_response::Code::generated_enum_descriptor_data());
        enums.push(relay_response::Code::generated_enum_descriptor_data());
        ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
            file_descriptor_proto(),
            deps,
            messages,
            enums,
        )
    });
    ::protobuf::reflect::FileDescriptor::new_generated_2(file_descriptor)
}
